# -*- coding: utf-8 -*-
"""
Ïï°ÏÖò Ï∂îÏ∂úÍ∏∞ - Î©îÏãúÏßÄÏóêÏÑú ÌïÑÏöîÌïú Ïï°ÏÖòÍ≥º TODO Ìï≠Î™©ÏùÑ Ï∂îÏ∂ú
"""
import asyncio
import logging
import json
import re
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)


@dataclass
class ActionItem:
    """Ïï°ÏÖò ÏïÑÏù¥ÌÖú Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§"""
    action_id: str
    action_type: str  # meeting, task, deadline, response, review, etc.
    title: str
    description: str
    deadline: Optional[datetime]
    priority: str  # high, medium, low
    assignee: str  # ÎÇòÏóêÍ≤å Ìï†ÎãπÎêú ÏûëÏóÖ
    requester: str  # ÏöîÏ≤≠Ïûê
    source_message_id: str
    context: Dict  # Ï∂îÍ∞Ä Ïª®ÌÖçÏä§Ìä∏ Ï†ïÎ≥¥
    created_at: datetime = None
    status: str = "pending"  # pending, in_progress, completed, cancelled
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now()
    
    def to_dict(self) -> Dict:
        """ÎîïÏÖîÎÑàÎ¶¨Î°ú Î≥ÄÌôò"""
        return {
            "action_id": self.action_id,
            "action_type": self.action_type,
            "title": self.title,
            "description": self.description,
            "deadline": self.deadline.isoformat() if self.deadline else None,
            "priority": self.priority,
            "assignee": self.assignee,
            "requester": self.requester,
            "source_message_id": self.source_message_id,
            "context": self.context,
            "created_at": self.created_at.isoformat(),
            "status": self.status
        }


class ActionExtractor:
    """Ïï°ÏÖò Ï∂îÏ∂úÍ∏∞"""
    
    def __init__(self):
        # Ïï°ÏÖò ÌÉÄÏûÖÎ≥Ñ Ìå®ÌÑ¥ Ï†ïÏùò
        self.action_patterns = {
            "meeting": {
                "keywords": ["ÎØ∏ÌåÖ", "meeting", "ÌöåÏùò", "conference", "ÌôîÏÉÅ", "video call"],
                "patterns": [
                    r"(\d{1,2}:\d{2}|\d{1,2}Ïãú).*?ÎØ∏ÌåÖ",
                    r"ÎØ∏ÌåÖ.*?(\d{1,2}:\d{2}|\d{1,2}Ïãú)",
                    r"(\d{1,2}Ïõî\s*\d{1,2}Ïùº).*?ÌöåÏùò",
                    r"ÌöåÏùò.*?(\d{1,2}Ïõî\s*\d{1,2}Ïùº)"
                ]
            },
            "task": {
                "keywords": ["ÏûëÏóÖ", "task", "ÏóÖÎ¨¥", "ÌîÑÎ°úÏ†ùÌä∏", "project", "Í≥ºÏ†ú"],
                "patterns": [
                    r"(\w+).*?ÏûëÏóÖ.*?ÏöîÏ≤≠",
                    r"(\w+).*?ÌîÑÎ°úÏ†ùÌä∏.*?ÏßÑÌñâ",
                    r"(\w+).*?ÏóÖÎ¨¥.*?Ï≤òÎ¶¨"
                ]
            },
            "deadline": {
                "keywords": ["Îç∞ÎìúÎùºÏù∏", "deadline", "Í∏∞Ìïú", "ÎßàÍ∞ê", "Ï†úÏ∂ú", "ÏôÑÎ£å"],
                "patterns": [
                    r"(\d{1,2}Ïõî\s*\d{1,2}Ïùº).*?ÍπåÏßÄ",
                    r"(\d{1,2}/\d{1,2}).*?ÎßàÍ∞ê",
                    r"(Ïò§Îäò|ÎÇ¥Ïùº|Ïù¥Î≤à Ï£º|Îã§Ïùå Ï£º).*?ÍπåÏßÄ",
                    r"(\w+ÏöîÏùº).*?Ï†úÏ∂ú"
                ]
            },
            "review": {
                "keywords": ["Í≤ÄÌÜ†", "review", "ÌôïÏù∏", "check", "ÌîºÎìúÎ∞±", "feedback"],
                "patterns": [
                    r"(\w+).*?Í≤ÄÌÜ†.*?Î∂ÄÌÉÅ",
                    r"(\w+).*?ÌôïÏù∏.*?ÏöîÏ≤≠",
                    r"(\w+).*?ÌîºÎìúÎ∞±.*?Ï£ºÏÑ∏Ïöî"
                ]
            },
            "response": {
                "keywords": ["ÎãµÎ≥Ä", "response", "ÌöåÏã†", "reply", "ÏùëÎãµ"],
                "patterns": [
                    r"ÎãµÎ≥Ä.*?Î∂ÄÌÉÅ",
                    r"ÌöåÏã†.*?ÏöîÏ≤≠",
                    r"ÏùëÎãµ.*?Í∏∞Îã§Î¶ΩÎãàÎã§"
                ]
            }
        }
        
        # Ïö∞ÏÑ†ÏàúÏúÑ ÌÇ§ÏõåÎìú
        self.priority_keywords = {
            "high": ["Í∏¥Í∏â", "urgent", "asap", "Ï¶âÏãú", "Î∞îÎ°ú", "ÏßÄÍ∏à"],
            "medium": ["Ï§ëÏöî", "important", "Ïö∞ÏÑ†", "Îπ†Î•¥Í≤å"],
            "low": ["Ïó¨Ïú†", "Ìé∏Ìïú", "ÏãúÍ∞Ñ"]
        }
    
    def extract_actions(self, message_data: Dict, user_email: str = "pm.1@quickchat.dev") -> List[ActionItem]:
        """Î©îÏãúÏßÄÏóêÏÑú Ïï°ÏÖò Ï∂îÏ∂ú
        
        Args:
            message_data: Î©îÏãúÏßÄ Îç∞Ïù¥ÌÑ∞
            user_email: ÏÇ¨Ïö©Ïûê(PM) Ïù¥Î©îÏùº Ï£ºÏÜå (Í∏∞Î≥∏Í∞í: pm.1@quickchat.dev)
            
        Returns:
            Ïï°ÏÖò ÏïÑÏù¥ÌÖú Î¶¨Ïä§Ìä∏
            
        Note:
            ÏÇ¨Ïö©Ïûê(PM)ÏóêÍ≤å **Ïò®** Î©îÏãúÏßÄÎßå TODOÎ°ú Î≥ÄÌôòÌï©ÎãàÎã§.
            ÏÇ¨Ïö©ÏûêÍ∞Ä **Î≥¥ÎÇ∏** Î©îÏãúÏßÄÎäî Ï†úÏô∏Îê©ÎãàÎã§.
        """
        content = message_data.get("body", "") or message_data.get("content", "")
        subject = message_data.get("subject", "")
        sender = message_data.get("sender", "")
        sender_email = message_data.get("sender_email", "")
        msg_id = message_data.get("msg_id", f"msg_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
        
        # ‚úÖ Ï§ëÏöî: ÏÇ¨Ïö©Ïûê(PM)Í∞Ä Î≥¥ÎÇ∏ Î©îÏãúÏßÄÎäî TODOÎ°ú ÎßåÎì§ÏßÄ ÏïäÏùå
        if sender_email and sender_email.lower() == user_email.lower():
            logger.debug(f"‚è≠Ô∏è ÏÇ¨Ïö©ÏûêÍ∞Ä Î≥¥ÎÇ∏ Î©îÏãúÏßÄ Ïä§ÌÇµ: {msg_id}")
            return []
        
        # Ïù¥Î©îÏùº Ï£ºÏÜåÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ sender Ïù¥Î¶ÑÏúºÎ°ú Ï≤¥ÌÅ¨ (chat Î©îÏãúÏßÄ)
        if not sender_email and sender and "kim jihoon" in sender.lower():
            logger.debug(f"‚è≠Ô∏è ÏÇ¨Ïö©ÏûêÍ∞Ä Î≥¥ÎÇ∏ Î©îÏãúÏßÄ Ïä§ÌÇµ (Ïù¥Î¶Ñ Í∏∞Î∞ò): {msg_id}")
            return []
        
        actions = []
        
        # Í∞Å Ïï°ÏÖò ÌÉÄÏûÖÎ≥ÑÎ°ú Ï∂îÏ∂ú
        for action_type, config in self.action_patterns.items():
            extracted_actions = self._extract_action_type(
                content, subject, sender, msg_id, action_type, config
            )
            actions.extend(extracted_actions)
        
        # Ï§ëÎ≥µ Ï†úÍ±∞ Î∞è Ï†ïÎ¶¨
        actions = self._deduplicate_actions(actions)
        
        if actions:
            logger.info(f"üéØ {len(actions)}Í∞úÏùò Ïï°ÏÖò Ï∂îÏ∂ú: {msg_id} (Î∞úÏã†Ïûê: {sender})")
        return actions
    
    def _extract_action_type(self, content: str, subject: str, sender: str, 
                           msg_id: str, action_type: str, config: Dict) -> List[ActionItem]:
        """ÌäπÏ†ï Ïï°ÏÖò ÌÉÄÏûÖ Ï∂îÏ∂ú"""
        actions = []
        text = f"{subject} {content}"
        
        # ÌÇ§ÏõåÎìú Í∏∞Î∞ò Ï∂îÏ∂ú
        for keyword in config["keywords"]:
            if keyword in text.lower():
                action = self._create_action_from_keyword(
                    text, keyword, action_type, sender, msg_id
                )
                if action:
                    actions.append(action)
        
        # Ìå®ÌÑ¥ Í∏∞Î∞ò Ï∂îÏ∂ú
        for pattern in config["patterns"]:
            matches = re.findall(pattern, text, re.IGNORECASE)
            for match in matches:
                action = self._create_action_from_pattern(
                    text, match, action_type, sender, msg_id, pattern
                )
                if action:
                    actions.append(action)
        
        return actions
    
    def _create_action_from_keyword(self, text: str, keyword: str, action_type: str, 
                                  sender: str, msg_id: str) -> Optional[ActionItem]:
        """ÌÇ§ÏõåÎìúÎ°úÎ∂ÄÌÑ∞ Ïï°ÏÖò ÏÉùÏÑ±"""
        # ÌÇ§ÏõåÎìú Ï£ºÎ≥Ä Î¨∏Îß• Ï∂îÏ∂ú
        context = self._extract_context_around_keyword(text, keyword)
        
        if not context:
            return None
        
        # Ïï°ÏÖò Ï†úÎ™© ÏÉùÏÑ±
        title = self._generate_action_title(action_type, context)
        
        # Ïö∞ÏÑ†ÏàúÏúÑ Í≤∞Ï†ï
        priority = self._determine_priority(text)
        
        # Îç∞ÎìúÎùºÏù∏ Ï∂îÏ∂ú
        deadline = self._extract_deadline(text)
        
        return ActionItem(
            action_id=f"{action_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            action_type=action_type,
            title=title,
            description=context,
            deadline=deadline,
            priority=priority,
            assignee="ÎÇò",
            requester=sender,
            source_message_id=msg_id,
            context={"keyword": keyword, "extracted_from": "keyword"}
        )
    
    def _create_action_from_pattern(self, text: str, match: str, action_type: str, 
                                  sender: str, msg_id: str, pattern: str) -> Optional[ActionItem]:
        """Ìå®ÌÑ¥ Îß§Ïπ≠ÏúºÎ°úÎ∂ÄÌÑ∞ Ïï°ÏÖò ÏÉùÏÑ±"""
        # Îß§Ïπ≠Îêú Î∂ÄÎ∂Ñ Ï£ºÎ≥Ä Î¨∏Îß• Ï∂îÏ∂ú
        context = self._extract_context_around_match(text, match)
        
        if not context:
            return None
        
        # Ïï°ÏÖò Ï†úÎ™© ÏÉùÏÑ±
        title = self._generate_action_title(action_type, context)
        
        # Ïö∞ÏÑ†ÏàúÏúÑ Í≤∞Ï†ï
        priority = self._determine_priority(text)
        
        # Îç∞ÎìúÎùºÏù∏ Ï∂îÏ∂ú (ÌäπÎ≥ÑÌûà Ìå®ÌÑ¥ÏóêÏÑú)
        deadline = self._extract_deadline_from_match(match, action_type)
        
        return ActionItem(
            action_id=f"{action_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            action_type=action_type,
            title=title,
            description=context,
            deadline=deadline,
            priority=priority,
            assignee="ÎÇò",
            requester=sender,
            source_message_id=msg_id,
            context={"match": match, "pattern": pattern, "extracted_from": "pattern"}
        )
    
    def _extract_context_around_keyword(self, text: str, keyword: str) -> str:
        """ÌÇ§ÏõåÎìú Ï£ºÎ≥Ä Î¨∏Îß• Ï∂îÏ∂ú"""
        keyword_pos = text.lower().find(keyword.lower())
        if keyword_pos == -1:
            return ""
        
        # ÌÇ§ÏõåÎìú ÏïûÎí§Î°ú 100ÏûêÏî© Ï∂îÏ∂ú
        start = max(0, keyword_pos - 100)
        end = min(len(text), keyword_pos + len(keyword) + 100)
        
        context = text[start:end].strip()
        return context
    
    def _extract_context_around_match(self, text: str, match: str) -> str:
        """Îß§Ïπ≠Îêú Î∂ÄÎ∂Ñ Ï£ºÎ≥Ä Î¨∏Îß• Ï∂îÏ∂ú"""
        match_pos = text.find(match)
        if match_pos == -1:
            return ""
        
        # Îß§Ïπ≠ Î∂ÄÎ∂Ñ ÏïûÎí§Î°ú 150ÏûêÏî© Ï∂îÏ∂ú
        start = max(0, match_pos - 150)
        end = min(len(text), match_pos + len(match) + 150)
        
        context = text[start:end].strip()
        return context
    
    def _generate_action_title(self, action_type: str, context: str) -> str:
        """Ïï°ÏÖò Ï†úÎ™© ÏÉùÏÑ± - Ìïú Îã®Ïñ¥Î°ú Í∞ÑÍ≤∞ÌïòÍ≤å"""
        titles = {
            "meeting": "ÎØ∏ÌåÖÏ∞∏ÏÑù",
            "task": "ÏóÖÎ¨¥Ï≤òÎ¶¨",
            "deadline": "ÎßàÍ∞êÏûëÏóÖ",
            "review": "Î¨∏ÏÑúÍ≤ÄÌÜ†",
            "response": "ÎãµÎ≥ÄÏûëÏÑ±"
        }
        
        # Ìïú Îã®Ïñ¥Î°ú Í∞ÑÍ≤∞ÌïòÍ≤å Î∞òÌôò
        return titles.get(action_type, "Ïï°ÏÖòÏàòÌñâ")
    
    def _determine_priority(self, text: str) -> str:
        """Ïö∞ÏÑ†ÏàúÏúÑ Í≤∞Ï†ï"""
        text_lower = text.lower()
        
        for priority, keywords in self.priority_keywords.items():
            if any(keyword in text_lower for keyword in keywords):
                return priority
        
        return "medium"  # Í∏∞Î≥∏Í∞í
    
    def _extract_deadline(self, text: str) -> Optional[datetime]:
        """Îç∞ÎìúÎùºÏù∏ Ï∂îÏ∂ú"""
        # ÎÇ†Ïßú Ìå®ÌÑ¥Îì§
        date_patterns = [
            r"(\d{1,2}Ïõî\s*\d{1,2}Ïùº)",
            r"(\d{1,2}/\d{1,2})",
            r"(\d{4}-\d{2}-\d{2})",
            r"(Ïò§Îäò|ÎÇ¥Ïùº|Ïù¥Î≤à Ï£º|Îã§Ïùå Ï£º)",
            r"(\w+ÏöîÏùº)"
        ]
        
        for pattern in date_patterns:
            match = re.search(pattern, text)
            if match:
                date_str = match.group(1)
                return self._parse_date_string(date_str)
        
        return None
    
    def _extract_deadline_from_match(self, match: str, action_type: str) -> Optional[datetime]:
        """Îß§Ïπ≠Îêú Î∂ÄÎ∂ÑÏóêÏÑú Îç∞ÎìúÎùºÏù∏ Ï∂îÏ∂ú"""
        if action_type == "deadline":
            return self._parse_date_string(match)
        elif action_type == "meeting":
            return self._parse_time_string(match)
        
        return None
    
    def _parse_date_string(self, date_str: str) -> Optional[datetime]:
        """ÎÇ†Ïßú Î¨∏ÏûêÏó¥ ÌååÏã±"""
        try:
            # Ïò§Îäò, ÎÇ¥Ïùº Ï≤òÎ¶¨
            if "Ïò§Îäò" in date_str:
                return datetime.now().replace(hour=18, minute=0, second=0, microsecond=0)
            elif "ÎÇ¥Ïùº" in date_str:
                tomorrow = datetime.now() + timedelta(days=1)
                return tomorrow.replace(hour=18, minute=0, second=0, microsecond=0)
            
            # Ïõî/Ïùº ÌòïÏãù (Ïòà: 1Ïõî 15Ïùº)
            month_day_match = re.match(r"(\d{1,2})Ïõî\s*(\d{1,2})Ïùº", date_str)
            if month_day_match:
                month = int(month_day_match.group(1))
                day = int(month_day_match.group(2))
                year = datetime.now().year
                return datetime(year, month, day, 18, 0, 0)
            
            # M/D ÌòïÏãù (Ïòà: 1/15)
            md_match = re.match(r"(\d{1,2})/(\d{1,2})", date_str)
            if md_match:
                month = int(md_match.group(1))
                day = int(md_match.group(2))
                year = datetime.now().year
                return datetime(year, month, day, 18, 0, 0)
            
            # ÏöîÏùº Ï≤òÎ¶¨ (Îã§Ïùå Ìï¥Îãπ ÏöîÏùº)
            weekdays = ["ÏõîÏöîÏùº", "ÌôîÏöîÏùº", "ÏàòÏöîÏùº", "Î™©ÏöîÏùº", "Í∏àÏöîÏùº", "ÌÜ†ÏöîÏùº", "ÏùºÏöîÏùº"]
            for i, weekday in enumerate(weekdays):
                if weekday in date_str:
                    today = datetime.now().weekday()
                    days_ahead = (i - today) % 7
                    if days_ahead == 0:  # Ïò§ÎäòÏù¥Î©¥ ÎÇ¥Ïùº
                        days_ahead = 7
                    target_date = datetime.now() + timedelta(days=days_ahead)
                    return target_date.replace(hour=18, minute=0, second=0, microsecond=0)
            
        except Exception as e:
            logger.error(f"ÎÇ†Ïßú ÌååÏã± Ïò§Î•ò: {e}")
        
        return None
    
    def _parse_time_string(self, time_str: str) -> Optional[datetime]:
        """ÏãúÍ∞Ñ Î¨∏ÏûêÏó¥ ÌååÏã±"""
        try:
            # HH:MM ÌòïÏãù
            time_match = re.match(r"(\d{1,2}):(\d{2})", time_str)
            if time_match:
                hour = int(time_match.group(1))
                minute = int(time_match.group(2))
                today = datetime.now()
                return today.replace(hour=hour, minute=minute, second=0, microsecond=0)
            
            # HÏãú ÌòïÏãù
            hour_match = re.match(r"(\d{1,2})Ïãú", time_str)
            if hour_match:
                hour = int(hour_match.group(1))
                today = datetime.now()
                return today.replace(hour=hour, minute=0, second=0, microsecond=0)
            
        except Exception as e:
            logger.error(f"ÏãúÍ∞Ñ ÌååÏã± Ïò§Î•ò: {e}")
        
        return None
    
    def _deduplicate_actions(self, actions: List[ActionItem]) -> List[ActionItem]:
        """Ï§ëÎ≥µ Ïï°ÏÖò Ï†úÍ±∞"""
        seen = set()
        unique_actions = []
        
        for action in actions:
            # Ï†úÎ™©Í≥º ÏÑ§Î™ÖÏùò Ìï¥ÏãúÎ°ú Ï§ëÎ≥µ Ï≤¥ÌÅ¨
            action_key = f"{action.title}_{action.description[:50]}"
            if action_key not in seen:
                seen.add(action_key)
                unique_actions.append(action)
        
        return unique_actions
    
    async def batch_extract_actions(self, messages: List[Dict], user_email: str = "pm.1@quickchat.dev") -> List[ActionItem]:
        """Ïó¨Îü¨ Î©îÏãúÏßÄÏóêÏÑú Ïï°ÏÖò ÏùºÍ¥Ñ Ï∂îÏ∂ú
        
        Args:
            messages: Î©îÏãúÏßÄ Î¶¨Ïä§Ìä∏
            user_email: ÏÇ¨Ïö©Ïûê(PM) Ïù¥Î©îÏùº Ï£ºÏÜå
            
        Returns:
            Ïï°ÏÖò ÏïÑÏù¥ÌÖú Î¶¨Ïä§Ìä∏
        """
        all_actions = []
        
        for message in messages:
            try:
                actions = self.extract_actions(message, user_email=user_email)
                all_actions.extend(actions)
            except Exception as e:
                logger.error(f"Î©îÏãúÏßÄ Ïï°ÏÖò Ï∂îÏ∂ú Ïò§Î•ò: {e}")
                continue
        
        # Ïö∞ÏÑ†ÏàúÏúÑÎ≥ÑÎ°ú Ï†ïÎ†¨
        priority_order = {"high": 3, "medium": 2, "low": 1}
        all_actions.sort(
            key=lambda x: (priority_order.get(x.priority, 1), x.deadline or datetime.max),
            reverse=True
        )
        
        logger.info(f"üéØ Ï¥ù {len(all_actions)}Í∞úÏùò Ïï°ÏÖò Ï∂îÏ∂ú ÏôÑÎ£å")
        return all_actions


# ÌÖåÏä§Ìä∏ Ìï®Ïàò
async def test_action_extractor():
    """Ïï°ÏÖò Ï∂îÏ∂úÍ∏∞ ÌÖåÏä§Ìä∏"""
    extractor = ActionExtractor()
    
    test_messages = [
        {
            "msg_id": "msg_001",
            "sender": "ÍπÄÎ∂ÄÏû•",
            "subject": "Í∏¥Í∏â: ÎÇ¥Ïùº Ïò§Ï†Ñ 10Ïãú ÌåÄ ÎØ∏ÌåÖ",
            "body": "ÎÇ¥Ïùº Ïò§Ï†Ñ 10ÏãúÏóê 3Ï∏µ ÌöåÏùòÏã§ÏóêÏÑú Í∏¥Í∏â ÌåÄ ÎØ∏ÌåÖÏù¥ ÏûàÏäµÎãàÎã§. ÌîÑÎ°úÏ†ùÌä∏ Îç∞ÎìúÎùºÏù∏Ïù¥ ÎãπÍ≤®Ï†∏ÏÑú Ï¶âÏãú Ï§ÄÎπÑÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.",
            "content": "ÎÇ¥Ïùº Ïò§Ï†Ñ 10ÏãúÏóê 3Ï∏µ ÌöåÏùòÏã§ÏóêÏÑú Í∏¥Í∏â ÌåÄ ÎØ∏ÌåÖÏù¥ ÏûàÏäµÎãàÎã§. ÌîÑÎ°úÏ†ùÌä∏ Îç∞ÎìúÎùºÏù∏Ïù¥ ÎãπÍ≤®Ï†∏ÏÑú Ï¶âÏãú Ï§ÄÎπÑÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§."
        },
        {
            "msg_id": "msg_002",
            "sender": "Î∞ïÎåÄÎ¶¨",
            "subject": "ÌîÑÎ°úÏ†ùÌä∏ Î¨∏ÏÑú Í≤ÄÌÜ† ÏöîÏ≤≠",
            "body": "ÌîÑÎ°úÏ†ùÌä∏ Î¨∏ÏÑú Í≤ÄÌÜ† Î∂ÄÌÉÅÎìúÎ¶ΩÎãàÎã§. Í∏àÏöîÏùºÍπåÏßÄ ÌîºÎìúÎ∞± Ï£ºÏãúÎ©¥ Í∞êÏÇ¨ÌïòÍ≤†ÏäµÎãàÎã§.",
            "content": "ÌîÑÎ°úÏ†ùÌä∏ Î¨∏ÏÑú Í≤ÄÌÜ† Î∂ÄÌÉÅÎìúÎ¶ΩÎãàÎã§. Í∏àÏöîÏùºÍπåÏßÄ ÌîºÎìúÎ∞± Ï£ºÏãúÎ©¥ Í∞êÏÇ¨ÌïòÍ≤†ÏäµÎãàÎã§."
        },
        {
            "msg_id": "msg_003",
            "sender": "Ïù¥ÌåÄÏû•",
            "subject": "ÏõîÏöîÏùºÍπåÏßÄ Î≥¥Í≥†ÏÑú Ï†úÏ∂ú",
            "body": "ÏõîÏöîÏùºÍπåÏßÄ Î∂ÑÍ∏∞ Î≥¥Í≥†ÏÑú Ï†úÏ∂úÌï¥Ï£ºÏÑ∏Ïöî. Í∏¥Í∏âÌï©ÎãàÎã§.",
            "content": "ÏõîÏöîÏùºÍπåÏßÄ Î∂ÑÍ∏∞ Î≥¥Í≥†ÏÑú Ï†úÏ∂úÌï¥Ï£ºÏÑ∏Ïöî. Í∏¥Í∏âÌï©ÎãàÎã§."
        }
    ]
    
    all_actions = await extractor.batch_extract_actions(test_messages)
    
    print(f"üéØ Ï¥ù {len(all_actions)}Í∞úÏùò Ïï°ÏÖò Ï∂îÏ∂ú:")
    for i, action in enumerate(all_actions, 1):
        print(f"\n{i}. {action.action_type.upper()} - {action.title}")
        print(f"   Ïö∞ÏÑ†ÏàúÏúÑ: {action.priority}")
        print(f"   ÏöîÏ≤≠Ïûê: {action.requester}")
        if action.deadline:
            print(f"   Îç∞ÎìúÎùºÏù∏: {action.deadline.strftime('%Y-%m-%d %H:%M')}")
        print(f"   ÏÑ§Î™Ö: {action.description[:100]}...")


if __name__ == "__main__":
    asyncio.run(test_action_extractor())
